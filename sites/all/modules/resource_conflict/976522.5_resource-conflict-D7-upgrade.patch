From d310ba7b9b59c566c1f377648c4c07309d6296be Mon Sep 17 00:00:00 2001
From: Andreas Gill <andreas.gill@mightech.de>
Date: Mon, 2 May 2011 15:10:18 -0400
Subject: [PATCH 1/4] #976522: Update the info file for Drupal 7.

---
 resource_conflict.info |   10 +++++++---
 1 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/resource_conflict.info b/resource_conflict.info
index 44f6fcc..778679a 100644
--- a/resource_conflict.info
+++ b/resource_conflict.info
@@ -1,7 +1,11 @@
 name = Resource Conflict
 description = Provides a mechanism for notifying of conflict based on nodereferenced resources.
-dependencies[] = nodereference
+dependencies[] = node_reference
 dependencies[] = date_api
-dependencies[] = content
+dependencies[] = cck
 project = "resource_conflict"
-core = 6.x
\ No newline at end of file
+core = 7.x
+
+files[] = resource_conflict.install
+files[] = resource_conflict.module
+
-- 
1.7.4.4


From dbb4caca6a717423c67dc2b28751e2fe9731ab8c Mon Sep 17 00:00:00 2001
From: Andreas Gill <andreas.gill@mightech.de>
Date: Mon, 2 May 2011 15:11:29 -0400
Subject: [PATCH 2/4] #976522: Update the install file for Drupal 7.

---
 resource_conflict.install |   47 +++++++++++++-------------------------------
 1 files changed, 14 insertions(+), 33 deletions(-)

diff --git a/resource_conflict.install b/resource_conflict.install
index 518924f..236ab67 100644
--- a/resource_conflict.install
+++ b/resource_conflict.install
@@ -1,51 +1,32 @@
 <?php
-// $Id
+/**
+ * @file
+ * Install, update and uninstall functions for the resource_conflict module.
+ *
+ */
 
 /**
- * Implementation of hook_uninstall
+ * Implements hook_uninstall().
  */
 function resource_conflict_uninstall() {
   _resource_conflict_variable_delete_like('rc_type_%');
   _resource_conflict_variable_delete_like('rc_date_field_%');
   _resource_conflict_variable_delete_like('rc_reference_fields_%');
-  
-  variable_del('rc_types');
-}
 
-/**
- * Update from version 1.x to version 2.x.
- */
-function resource_conflict_update_5200() {
-  $ret = array();
-  
-  // Rename all resource_conflict_$type variables to rc_type_$type
-  $q = "SELECT name FROM {variable} WHERE name LIKE 'resource_conflict_%' AND name NOT LIKE 'resource_conflict_fields_%'";
-  $result = db_query($q);
-  while($row = db_fetch_array($result)) {
-    $type = str_replace('resource_conflict_', '', $row['name']);
-    $q = "UPDATE {variable} SET name = 'rc_type_" . $type .  "' WHERE name = 'resource_conflict_" . $type . "'";
-    $ret[] = update_sql($q);
-    
-    // Also set the type to be event
-    variable_set('rc_date_field_' . $type, 'event');
-    
-    // Finally, rename the enabled fields for the type
-    $q = "UPDATE {variable} SET name = 'rc_reference_fields_" . $type . "' WHERE name = 'resource_conflict_fields_" . $type . "'";
-    $ret[] = update_sql($q);
-  }
-  
-  return $ret;
+  variable_del('rc_types');
 }
 
 /**
  * Delete all variables matching a pattern using SQL 'LIKE' syntax.
  * @param $pattern
- *   The pattern of variables to delete. 
+ *   The pattern of variables to delete.
  */
 function _resource_conflict_variable_delete_like($pattern) {
-  $q = "SELECT name FROM {variable} WHERE name LIKE '%s'";
-  $result = db_query($q, $pattern);
-  while ($row = db_fetch_array($result)) {
-    variable_del($row['name']);
+  $q = "SELECT name FROM {variable} WHERE name LIKE :pattern";
+  // TODO Please convert this statement to the D7 database API syntax.
+  $result = db_query("SELECT name FROM {variable} WHERE name LIKE :pattern", array(':pattern' => $pattern));
+  foreach ($result as $record) {
+    variable_del($record->name);
   }
 }
+
-- 
1.7.4.4


From 1aa4bf1fb7ef871365db60b691a3c3e0cefab5f1 Mon Sep 17 00:00:00 2001
From: Andreas Gill <andreas.gill@mightech.de>
Date: Mon, 2 May 2011 15:16:37 -0400
Subject: [PATCH 3/4] #976522: Update Resource Conflict to Drupal 7.

---
 resource_conflict.module |  253 +++++++++++++++++++++-------------------------
 1 files changed, 115 insertions(+), 138 deletions(-)

diff --git a/resource_conflict.module b/resource_conflict.module
index 179cab9..a75606f 100644
--- a/resource_conflict.module
+++ b/resource_conflict.module
@@ -2,60 +2,52 @@
 //VIM setup ex: et sw=2 ts=2 syntax=php
 
 /**
- * Implementation of hook_nodeapi
- *
- * Determine if a required resource is currently booked.
+ * Implements hook_node_validate().
  */
-function resource_conflict_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
-  switch ($op) {
-    case 'validate':
-      $type = $node->type;
-      if (!variable_get('rc_type_' . $type, FALSE)) {
-        // Conflict handling is not enabled for this node.
-        break;
-      }
-
-      // Find the date field to use for time overlapping_node_ids detection.
-      $date_field = variable_get('rc_date_field_' . $type, FALSE);
+function resource_conflict_node_validate($node, $form) {
+  $type = $node->type;
+  if (!variable_get('rc_type_' . $type, FALSE)) {
+    // Conflict handling is not enabled for this node.
+    return;
+  }
 
-      $overlapping_node_ids = array();
+  // Find the date field to use for time overlapping_node_ids detection.
+  $date_field = variable_get('rc_date_field_' . $type, FALSE);
 
-      if (strpos($date_field, 'field_', 0) === 0) {
-        // Get the start and end Date of the current node
-        $start = $node->{$date_field}[0]['value'];
-        $end   = $node->{$date_field}[0]['value2'];
+  $overlapping_node_ids = array();
+  if (strpos($date_field, 'field_', 0) === 0) {
+    // Get the start and end Date of the current node
+    $start = $node->{$date_field}['und'][0]['value'];
+    $end   = $node->{$date_field}['und'][0]['value2'];
 
-        // Get all conflicting Date nodes
-        if (!empty($start) && !empty($end)) {
-          $overlapping_node_ids = _resource_conflict_overlaps_from_date($start, $end);
-        }
-        else {
-          // If we got here, someone broke the requirements, so turn off
-          // resource conflict for this type and notify an admin
-          _resource_conflict_disable($type);
-        }
-      }
-      if (!empty($node->event_start)) {
-        // Get all overlapping events
-        $tmp = _resource_conflict_overlaps_from_event($node->event_start, $node->event_end);
-        $overlapping_node_ids = array_unique(array_merge($overlapping_node_ids, $tmp));
-      }
-
-      // Load conflicting nodes
-      $conflicting_nodes = array();
-      foreach ($overlapping_node_ids as $nid) {
-        // Don't have the node conflict with itself
-        if ($nid != $node->nid) {
-          $conflicting_nodes[$nid] = node_load($nid);
-        }
-      }
+    // Get all conflicting Date nodes
+    if (!empty($start) && !empty($end)) {
+      $overlapping_node_ids = _resource_conflict_overlaps_from_date($start, $end);
+    }
+    else {
+      // If we got here, someone broke the requirements, so turn off
+      // resource conflict for this type and notify an admin
+      _resource_conflict_disable($type);
+    }
+  }
+  if (!empty($node->event_start)) {
+    // Get all overlapping events
+    $tmp = _resource_conflict_overlaps_from_event($node->event_start, $node->event_end);
+    $overlapping_node_ids = array_unique(array_merge($overlapping_node_ids, $tmp));
+  }
 
-      // Display conflict errors
-      _resource_conflict_display_conflict_errors($node, $conflicting_nodes);
-      break;
+  // Load conflicting nodes
+  $conflicting_nodes = array();
+  foreach ($overlapping_node_ids as $nid) {
+    // Don't have the node conflict with itself
+    if ($nid != $node->nid) {
+      $conflicting_nodes[$nid] = node_load($nid);
+    }
   }
-}
 
+  // Display conflict errors
+  _resource_conflict_display_conflict_errors($node, $conflicting_nodes);
+}
 
 /**
  * Compare our demand to the demand of overlapping nodes
@@ -79,16 +71,13 @@ function _resource_conflict_display_conflict_errors($node, $conflicting_nodes) {
 
     // display the error for each conflict
     foreach ($conflicting_resources as $conflicting_resource) {
-      $date_field = variable_get('rc_date_field_'. $conflicting_node->type, FALSE);
+      $date_field = variable_get('rc_date_field_' . $conflicting_node->type, FALSE);
       if (strpos($date_field, 'field_', 0) === 0) {
         $type = DATE_ISO;
-        // If date_start is not in DATE_ISO set the type to DATE_DATETIME.
-        if (!date_is_valid($date_start,DATE_ISO)) {
-          $type = DATE_DATETIME;
-        }
-
-        $start = format_date(date_convert($conflicting_node->{$date_field}[0]['value'], $type, DATE_UNIX));
-        $end   = format_date(date_convert($conflicting_node->{$date_field}[0]['value2'], $type, DATE_UNIX));
+        $startobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value']);
+        $start = $startobj->format('U');
+         $endobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value2']);
+        $end = $endobj->format('U');
       }
       else {
         $start = format_date($conflicting_node->event_start);
@@ -97,13 +86,13 @@ function _resource_conflict_display_conflict_errors($node, $conflicting_nodes) {
 
       $error = t('There is a resource conflict: <a href="@resource-url">%resource</a> is currently booked for <a href="@booker-url">%booker</a> from %start to %end. Please choose a different time or a different resource.',
         array(
-          '@booker-url' => url('node/'. $conflicting_node->nid),
-          '%booker' => $conflicting_node->title,
-          '@resource-url' => url('node/'. $conflicting_resource->nid),
-          '%resource' => $conflicting_resource->title,
-          '%start' => $start,
-          '%end' => $end,
-        )
+        '@booker-url' => url('node/' . $conflicting_node->nid),
+        '%booker' => $conflicting_node->title,
+        '@resource-url' => url('node/' . $conflicting_resource->nid),
+        '%resource' => $conflicting_resource->title,
+        '%start' => $start,
+        '%end' => $end,
+      )
       );
 
       // This is a bit of a hack, but there's no way with FAPI to have
@@ -119,7 +108,7 @@ function _resource_conflict_display_conflict_errors($node, $conflicting_nodes) {
 }
 
 /**
- * Implementation of hook_form_alter
+ * Implements hook_form_alter().
  */
 function resource_conflict_form_alter(&$form, $form_state, $form_id) {
   if ($form_id == 'node_type_form') {
@@ -145,17 +134,17 @@ function resource_conflict_form_alter(&$form, $form_state, $form_id) {
 
     $date_fields = array();
     if ($type != NULL) {
-      $type_info = content_types($type);
-      $fields = $type_info['fields'];
-
-      foreach ($fields as $field) {
-        if ($field['type'] == 'nodereference') {
-          $nodereference_fields[$field['field_name']] = $field['widget']['label'];
-        }
-        elseif (($field['type'] == 'date' || $field['type'] == 'datetime') && $field['todate'] == 'required' && $field['required']) {
-          $date_fields[$field['field_name']] = $field['widget']['label'];
-        }
-      }
+         $fields = field_info_instances('node',$type);
+         foreach ($fields as $fieldname => $field) {
+           if ($field['display']['default']['module'] == 'node_reference') {
+             $nodereference_fields[$fieldname] = $field['label'];
+           } elseif (($field['display']['default']['module'] == 'date')&&($field['required'] == 1)){
+             $fieldinfo = field_info_field($fieldname);
+             if ($fieldinfo['settings']['todate'] == 'required' ) {
+                $date_fields[$fieldname] = $field['label'];
+             }
+           }
+         }
     }
 
     if (empty($nodereference_fields)) {
@@ -238,7 +227,7 @@ function resource_conflict_form_alter(&$form, $form_state, $form_id) {
  */
 function resource_conflict_form_validate($form, &$form_state) {
   if ($form_state['values']['form_id'] == 'node_type_form') {
-    if ($form_state['values']['rc_type']) {
+    if (isset($form_state['values']['rc_type'])&&$form_state['values']['rc_type']) {
       $resource_selected = FALSE;
       foreach ($form_state['values']['rc_reference_fields'] as $field) {
         if ($field) {
@@ -268,7 +257,7 @@ function resource_conflict_form_submit($form, &$form_state) {
   }
 
   //make new entry if this type is conflict handled
-  if ($form_state['values']['rc_type']) {
+  if (isset($form_state['values']['rc_type'])&&($form_state['values']['rc_type'])) {
     $conflict_types[] = $type;
   }
 
@@ -297,11 +286,10 @@ function _resource_conflict_get_conflict_enabled_types() {
 function _resource_conflict_get_node_resource_demand($node) {
   $type = $node->type;
   $reference_fields = variable_get('rc_reference_fields_' . $type, array());
-
   $demand = array();
   foreach ($reference_fields as $reference_field) {
-    $references = $node->{$reference_field};
-    foreach ($references as $reference) {
+    $references = $node->{$reference_field}['und'];
+    foreach ($references as $key => $reference) {
       /**
        * Check to see if any referencable resources exist. If they don't, file
        * an error. This only matters when the nodereference field is set to
@@ -309,12 +297,12 @@ function _resource_conflict_get_node_resource_demand($node) {
        * file the error against the fake 'no_resources' element as CCK files
        * it's own "Illegal choice" error before we get called.
        */
-      if (is_array($reference['nid'])) {
-        form_set_error('no_resources', t('No bookable resources have been created. Please create resources to book before attempting to create a resource booking.'));
-      }
-      else if (is_numeric($reference['nid'])){
+      if (is_numeric($reference['nid'])) {
         $demand[$reference['nid']] = TRUE;
       }
+      else {
+        form_set_error('no_resources', t('No bookable resources have been created. Please create resources to book before attempting to create a resource booking.'));
+      }
     }
   }
   return $demand;
@@ -333,14 +321,10 @@ function _resource_conflict_get_node_resource_demand($node) {
 function _resource_conflict_overlaps_from_date($date_start, $date_end) {
   // Make the default type to DATE_ISO.
   $type = DATE_ISO;
-  // If date_start is not in DATE_ISO set the type to DATE_DATETIME.
-  if (!date_is_valid($date_start,DATE_ISO)) {
-    $type = DATE_DATETIME;
-  }
+  $date_startobj = New DateObject($date_start, 'GMT');
+  $date_endobj   = New DateObject($date_end, 'GMT');
 
-  $start = date_make_date($date_start, 'GMT', $type);
-  $end = date_make_date($date_end, 'GMT', $type);
-  return _resource_conflict_get_overlaps($start, $end);
+  return _resource_conflict_get_overlaps($date_startobj, $date_endobj);
 }
 
 /**
@@ -366,7 +350,7 @@ function _resource_conflict_overlaps_from_event($event_start, $event_end) {
  * 2. $end end is within the event time
  * 3. The event encompasses $start and $end
  * 4. Allow the end of one event to occur at the start of the next
- * 
+ *
  * @param $start
  *   The start time of events to search as dateAPI object
  * @param $end
@@ -375,59 +359,52 @@ function _resource_conflict_overlaps_from_event($event_start, $event_end) {
  *   An array of node ID's
  */
 function _resource_conflict_get_overlaps($start, $end) {
-  $date_start = date_convert($start, DATE_OBJECT, DATE_ISO);
-  $date_end = date_convert($end, DATE_OBJECT, DATE_ISO);
-  $event_start = date_convert($start, DATE_OBJECT, DATE_UNIX);
-  $event_end = date_convert($end, DATE_OBJECT, DATE_UNIX);
-
-  $rows = array();
-  $conflict_types = _resource_conflict_get_conflict_enabled_types();
-
-  foreach ($conflict_types as $type) {
-    $date_field = variable_get('rc_date_field_' . $type, FALSE);
-
-    if(strpos($date_field, 'field_', 0) === 0) {
-      $date_db_info = content_database_info(content_fields($date_field));
-      $date_table = '{' . $date_db_info['table'] . '}';
-
-      $start_field_name = $date_db_info['columns']['value']['column'];
-      $end_field_name = $date_db_info['columns']['value2']['column'];
-
-      $query = "SELECT DISTINCT {node}.nid FROM {node} INNER JOIN $date_table date_table ON {node}.vid = date_table.vid
-        WHERE('%s' >= date_table.$start_field_name AND '%s' < date_table.$end_field_name)
-        OR('%s' > date_table.$start_field_name AND '%s' <= date_table.$end_field_name)
-        OR('%s' <= date_table.$start_field_name AND '%s' >= date_table.$end_field_name)";
-
-      $result = db_query($query, $date_start, $date_start, $date_end, $date_end, $date_start, $date_end);
-
-      // Create an array of all of the results
-      while ($row = db_fetch_array($result)) {
-        $rows[] = $row['nid'];
-      }
-    }
-    elseif ($date_field == 'event') { //event enabled
-      $query = "SELECT DISTINCT nid FROM {event} WHERE (%d >= event_start AND %d < event_end)
-        OR (%d > event_start AND %d <= event_end)
-        OR (%d <= event_start AND %d >= event_end)";
-      $result = db_query($query, $event_start, $event_start, $event_end, $event_end, $event_start, $event_end);
-
-      // Create an array of all of the results
-      while($row = db_fetch_array($result)) {
-        $rows[] = $row['nid'];
-      }
-    }
-  }
-  return array_unique($rows);
-}
+     $date_start = $start->format(DATE_FORMAT_DATETIME);
+     $date_end = $end->format(DATE_FORMAT_DATETIME);
+     $rows = array();
+     $conflict_types = _resource_conflict_get_conflict_enabled_types();
+     foreach ($conflict_types as $type) {
+       $date_field = variable_get('rc_date_field_' . $type, FALSE);
+       if (strpos($date_field, 'field_', 0) === 0) {
+         $date_table = '{' . 'field_data_' . $date_field . '}';
+         $start_field_name = $date_field . '_value';
+         $end_field_name = $date_field . '_value2';
+         $query = "SELECT DISTINCT {node}.nid FROM {node} INNER JOIN $date_table date_table ON {node}.vid = date_table.revision_id
+          WHERE(:date_start >= date_table.$start_field_name AND :date_start < date_table.$end_field_name)
+          OR(:date_end > date_table.$start_field_name AND :date_end <= date_table.$end_field_name)
+          OR(:date_start <= date_table.$start_field_name AND :date_end >= date_table.$end_field_name)";
+         $result = db_query($query, array(':date_start' => $date_start, ':date_end' => $date_end,));
+         // Create an array of all of the results
+         //
+         while ($row = $result->fetchAssoc()) {
+           $rows[] = $row['nid'];
+         }
+       // @todo this is not yet testet under drupal7:
+       } elseif ($date_field == 'event') { //event enabled
+         $query = "SELECT DISTINCT nid FROM {event} WHERE (%d >= event_start AND %d < event_end)
+          OR (%d > event_start AND %d <= event_end)
+          OR (%d <= event_start AND %d >= event_end)";
+         $result = db_query("SELECT DISTINCT nid FROM {event} WHERE (%d >= :(%d AND %d < :%d
+          OR (%d > :(%d AND %d <= :%d
+          OR (%d <= :(%d AND %d >= :%d", array(':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, '' => $event_start, '' => $event_start, '' => $event_end, '' => $event_end, '' => $event_start, '' => $event_end));
+
+         // Create an array of all of the results
+         while ($row = db_fetch_array($result)) {
+           $rows[] = $row['nid'];
+         }
+       }
+     }
+     return array_unique($rows);
+   }
 
 /**
  * Disable resource conflict for a type, optionally notifying the user. A
  * message is always logged in the Drupal log. If the content type is not
  * conflict-enabled, nothing is changed.
- * 
+ *
  * @param $type
  *  The content type to disable.
- *  
+ *
  * @param $display
  *   If TRUE, display the message with drupal_set_message().
  */
@@ -435,7 +412,7 @@ function _resource_conflict_disable($type, $display = FALSE) {
   // If the requirements are no longer met, disable resource checking and
   // alert the site administrator.
   if (variable_get('rc_type_' . $type, FALSE)) {
-    variable_del('rc_type_'. $type);
+    variable_del('rc_type_' . $type);
     $msg = t('Resource Conflict has been disabled for the %type content type as the requirements for it are no longer met.', array('%type' => $type));
 
     if ($display) {
-- 
1.7.4.4


From 4200c535d829925ef3360d4af4f82392868e3db3 Mon Sep 17 00:00:00 2001
From: Andrew Berry <deviantintegral@gmail.com>
Date: Mon, 2 May 2011 15:33:00 -0400
Subject: [PATCH 4/4] #976522: Apply all coder style fixes.

---
 resource_conflict.module |  101 +++++++++++++++++++++++----------------------
 1 files changed, 52 insertions(+), 49 deletions(-)

diff --git a/resource_conflict.module b/resource_conflict.module
index a75606f..64bd34e 100644
--- a/resource_conflict.module
+++ b/resource_conflict.module
@@ -76,7 +76,7 @@ function _resource_conflict_display_conflict_errors($node, $conflicting_nodes) {
         $type = DATE_ISO;
         $startobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value']);
         $start = $startobj->format('U');
-         $endobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value2']);
+        $endobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value2']);
         $end = $endobj->format('U');
       }
       else {
@@ -134,17 +134,18 @@ function resource_conflict_form_alter(&$form, $form_state, $form_id) {
 
     $date_fields = array();
     if ($type != NULL) {
-         $fields = field_info_instances('node',$type);
-         foreach ($fields as $fieldname => $field) {
-           if ($field['display']['default']['module'] == 'node_reference') {
-             $nodereference_fields[$fieldname] = $field['label'];
-           } elseif (($field['display']['default']['module'] == 'date')&&($field['required'] == 1)){
-             $fieldinfo = field_info_field($fieldname);
-             if ($fieldinfo['settings']['todate'] == 'required' ) {
-                $date_fields[$fieldname] = $field['label'];
-             }
-           }
-         }
+      $fields = field_info_instances('node', $type);
+      foreach ($fields as $fieldname => $field) {
+        if ($field['display']['default']['module'] == 'node_reference') {
+          $nodereference_fields[$fieldname] = $field['label'];
+        }
+        elseif (($field['display']['default']['module'] == 'date')&&($field['required'] == 1)) {
+          $fieldinfo = field_info_field($fieldname);
+          if ($fieldinfo['settings']['todate'] == 'required' ) {
+            $date_fields[$fieldname] = $field['label'];
+          }
+        }
+      }
     }
 
     if (empty($nodereference_fields)) {
@@ -359,43 +360,45 @@ function _resource_conflict_overlaps_from_event($event_start, $event_end) {
  *   An array of node ID's
  */
 function _resource_conflict_get_overlaps($start, $end) {
-     $date_start = $start->format(DATE_FORMAT_DATETIME);
-     $date_end = $end->format(DATE_FORMAT_DATETIME);
-     $rows = array();
-     $conflict_types = _resource_conflict_get_conflict_enabled_types();
-     foreach ($conflict_types as $type) {
-       $date_field = variable_get('rc_date_field_' . $type, FALSE);
-       if (strpos($date_field, 'field_', 0) === 0) {
-         $date_table = '{' . 'field_data_' . $date_field . '}';
-         $start_field_name = $date_field . '_value';
-         $end_field_name = $date_field . '_value2';
-         $query = "SELECT DISTINCT {node}.nid FROM {node} INNER JOIN $date_table date_table ON {node}.vid = date_table.revision_id
-          WHERE(:date_start >= date_table.$start_field_name AND :date_start < date_table.$end_field_name)
-          OR(:date_end > date_table.$start_field_name AND :date_end <= date_table.$end_field_name)
-          OR(:date_start <= date_table.$start_field_name AND :date_end >= date_table.$end_field_name)";
-         $result = db_query($query, array(':date_start' => $date_start, ':date_end' => $date_end,));
-         // Create an array of all of the results
-         //
-         while ($row = $result->fetchAssoc()) {
-           $rows[] = $row['nid'];
-         }
-       // @todo this is not yet testet under drupal7:
-       } elseif ($date_field == 'event') { //event enabled
-         $query = "SELECT DISTINCT nid FROM {event} WHERE (%d >= event_start AND %d < event_end)
-          OR (%d > event_start AND %d <= event_end)
-          OR (%d <= event_start AND %d >= event_end)";
-         $result = db_query("SELECT DISTINCT nid FROM {event} WHERE (%d >= :(%d AND %d < :%d
-          OR (%d > :(%d AND %d <= :%d
-          OR (%d <= :(%d AND %d >= :%d", array(':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, '' => $event_start, '' => $event_start, '' => $event_end, '' => $event_end, '' => $event_start, '' => $event_end));
-
-         // Create an array of all of the results
-         while ($row = db_fetch_array($result)) {
-           $rows[] = $row['nid'];
-         }
-       }
-     }
-     return array_unique($rows);
-   }
+  $date_start = $start->format(DATE_FORMAT_DATETIME);
+  $date_end = $end->format(DATE_FORMAT_DATETIME);
+  $rows = array();
+  $conflict_types = _resource_conflict_get_conflict_enabled_types();
+  foreach ($conflict_types as $type) {
+    $date_field = variable_get('rc_date_field_' . $type, FALSE);
+    if (strpos($date_field, 'field_', 0) === 0) {
+      $date_table = '{' . 'field_data_' . $date_field . '}';
+      $start_field_name = $date_field . '_value';
+      $end_field_name = $date_field . '_value2';
+      $query = "SELECT DISTINCT {node}.nid FROM {node} INNER JOIN $date_table date_table ON {node}.vid = date_table.revision_id
+       WHERE(:date_start >= date_table.$start_field_name AND :date_start < date_table.$end_field_name)
+       OR(:date_end > date_table.$start_field_name AND :date_end <= date_table.$end_field_name)
+       OR(:date_start <= date_table.$start_field_name AND :date_end >= date_table.$end_field_name)";
+      $result = db_query($query, array(':date_start' => $date_start, ':date_end' => $date_end));
+
+      // Create an array of all of the results
+      while ($row = $result->fetchAssoc()) {
+        $rows[] = $row['nid'];
+      }
+    }
+    elseif ($date_field == 'event') {
+      // @todo this is not yet tested under drupal7.
+      // Event enabled.
+      $query = "SELECT DISTINCT nid FROM {event} WHERE (%d >= event_start AND %d < event_end)
+       OR (%d > event_start AND %d <= event_end)
+       OR (%d <= event_start AND %d >= event_end)";
+      $result = db_query("SELECT DISTINCT nid FROM {event} WHERE (%d >= :(%d AND %d < :%d
+       OR (%d > :(%d AND %d <= :%d
+       OR (%d <= :(%d AND %d >= :%d", array(':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, '' => $event_start, '' => $event_start, '' => $event_end, '' => $event_end, '' => $event_start, '' => $event_end));
+
+      // Create an array of all of the results
+      while ($row = db_fetch_array($result)) {
+        $rows[] = $row['nid'];
+      }
+    }
+  }
+  return array_unique($rows);
+}
 
 /**
  * Disable resource conflict for a type, optionally notifying the user. A
-- 
1.7.4.4

