<?php
//VIM setup ex: et sw=2 ts=2 syntax=php

/**
 * Implements hook_node_validate().
 */
function resource_conflict_node_validate($node, $form) {
  $type = $node->type;
  if (!variable_get('rc_type_' . $type, FALSE)) {
    // Conflict handling is not enabled for this node.
    return;
  }

  // Find the date field to use for time overlapping_node_ids detection.
  $date_field = variable_get('rc_date_field_' . $type, FALSE);

  $overlapping_node_ids = array();
  if (strpos($date_field, 'field_', 0) === 0) {
    // Get the start and end Date of the current node
    $start = $node->{$date_field}['und'][0]['value'];
    $end   = $node->{$date_field}['und'][0]['value2'];

    // Get all conflicting Date nodes
    if (!empty($start) && !empty($end)) {
      $overlapping_node_ids = _resource_conflict_overlaps_from_date($start, $end);
    }
    else {
      // If we got here, someone broke the requirements, so turn off
      // resource conflict for this type and notify an admin
      _resource_conflict_disable($type);
    }
  }
  if (!empty($node->event_start)) {
    // Get all overlapping events
    $tmp = _resource_conflict_overlaps_from_event($node->event_start, $node->event_end);
    $overlapping_node_ids = array_unique(array_merge($overlapping_node_ids, $tmp));
  }

  // Load conflicting nodes
  $conflicting_nodes = array();
  foreach ($overlapping_node_ids as $nid) {
    // Don't have the node conflict with itself
    if ($nid != $node->nid) {
      $conflicting_nodes[$nid] = node_load($nid);
    }
  }

  // Display conflict errors
  _resource_conflict_display_conflict_errors($node, $conflicting_nodes);
}

/* 
 * Take a conflicting object and turn it into a standardized array
 */
function _resource_conflict_create_conflict_array($type, $id) {
  $conflicting_entity = reset(entity_load($type, array($id)));
  $conflicting_resources[] = array(
    'id'  =>  entity_id($type, $conflicting_entity), 
    'label' => entity_label($type, $conflicting_entity),
    'type' => $type,
    'uri' => entity_uri($type, $conflicting_entity),
  );
 return $conflicting_resources; 
}


/**
 * Compare our demand to the demand of overlapping nodes
 * and display errors for the intersections
 *
 * @param $node the currently validating node
 * @param $conflicting_nodes array of nodes that overlap with this node
 */
function _resource_conflict_display_conflict_errors($node, $conflicting_nodes) {
  $our_demands = _resource_conflict_get_node_resource_demand($node);
  foreach ($conflicting_nodes as $conflicting_node) {
    $other_demands = _resource_conflict_get_node_resource_demand($conflicting_node);
    // select the resources that both this node and the other node demands
    $conflicting_resources = array();
    foreach ($other_demands as $other_demand) {
      foreach ($our_demands as $our_demand) {
        if ($our_demand['target_id'] == $other_demand['target_id'] && $our_demand['target_type'] == $other_demand['target_type']) {
          $conflicting_resources[] = _resource_conflict_create_conflict_array($our_demand['target_type'], $our_demand['target_id']);
        }
        if ($our_demand['target_type'] == 'taxonomy_term' && $other_demand['target_type'] == 'taxonomy_term') {
          // Check for conflicts with term parents.
          $our_demand_parents = taxonomy_get_parents_all($our_demand['target_id']);
          $other_demand_parents = taxonomy_get_parents_all($other_demand['target_id']);
          foreach ($our_demand_parents as $our_demand_parent) {
            if ($our_demand_parent->tid == $other_demand['target_id']) {
              $conflicting_resources[] = _resource_conflict_create_conflict_array('taxonomy_term', $our_demand_parent->tid); 
            }
          }
          foreach ($other_demand_parents as $other_demand_parent) {
            if ($other_demand_parent->tid == $our_demand['target_id']) {
              $conflicting_resources[] = _resource_conflict_create_conflict_array('taxonomy_term', $our_demand['target_id']); 
            }
          }
        }
      }
    }

    // display the error for each conflict 
    foreach ($conflicting_resources as $conflicting_resource) {
      $date_field = variable_get('rc_date_field_' . $conflicting_node->type, FALSE);
      if (strpos($date_field, 'field_', 0) === 0) {
        $type = DATE_ISO;
        $startobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value']);
        $start = $startobj->format('Y-m-d H:i');
        $endobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value2']);
        $end = $endobj->format('Y-m-d H:i');
      }
      else {
        $start = format_date($conflicting_node->event_start, 'Y-m-d H:i');
        $end = format_date($conflicting_node->event_end, 'Y-m-d H:i');
      }
      $error = t('There is a resource conflict: <a href="@resource-url">%resource</a> is currently booked for <a href="@booker-url">%booker</a> from %start to %end. Please choose a different time or a different resource.',
        array(
        '@booker-url' => url('node/' . $conflicting_node->nid),
        '%booker' => $conflicting_node->title,
        '@resource-url' => url($conflicting_resource['0']['uri']['path'], $conflicting_resource['0']['uri']['options']),
        '%resource' => $conflicting_resource['0']['label'],
        '%start' => $start,
        '%end' => $end,
      )
      );

      // This is a bit of a hack, but there's no way with FAPI to have
      // multiple form errors on the same field.  So, we just pass in
      // a bogus (but unique) ID for each error message, to ensure
      // that all conflicts are reported simultaneously.  We use the
      // title of the conflicting resource (thing) appended with the nid
      // of the conflicting node (reservation event).
      $conflict_id = $conflicting_resource['0']['type'] . '_' . $conflicting_resource['0']['id'] . '_' . $conflicting_node->nid;
      form_set_error($conflict_id, $error);
    }
  }
}

/**
 * Detect soft conflicts
 * Implements hook_node_insert().
 */
function resource_conflict_node_presave($node) {
  $type = $node->type;
  if (!variable_get('rc_type_' . $type, FALSE)) {
    // Conflict handling is not enabled for this node.
    return;
  }

  // Find the date field to use for time overlapping_node_ids detection.
  $date_field = variable_get('rc_date_field_' . $type, FALSE);

  $overlapping_node_ids = array();
  if (strpos($date_field, 'field_', 0) === 0) {
    // Get the start and end Date of the current node
    $start = $node->{$date_field}['und'][0]['value'];
    $end   = $node->{$date_field}['und'][0]['value2'];

    // Get all conflicting Date nodes
    if (!empty($start) && !empty($end)) {
      $overlapping_node_ids = _resource_conflict_overlaps_from_date($start, $end);
    }
    else {
      // If we got here, someone broke the requirements, so turn off
      // resource conflict for this type and notify an admin
      _resource_conflict_disable($type);
    }
  }
  if (!empty($node->event_start)) {
    // Get all overlapping events
    $tmp = _resource_conflict_overlaps_from_event($node->event_start, $node->event_end);
    $overlapping_node_ids = array_unique(array_merge($overlapping_node_ids, $tmp));
  }

  // Load conflicting nodes
  $conflicting_nodes = array();
  foreach ($overlapping_node_ids as $nid) {
    // Don't have the node conflict with itself
    if ($nid != $node->nid) {
      $conflicting_nodes[$nid] = node_load($nid);
    }
  }

  // Display conflict errors
  _resource_conflict_soft_conflict_errors($node, $conflicting_nodes);
}

function _resource_conflict_soft_conflict_errors($node, $conflicting_nodes) {
  // handle soft conflicts by displaying and saving a conflict node
  $our_demands = _resource_conflict_get_node_resource_demand($node);
  foreach ($conflicting_nodes as $conflicting_node) {
    $other_demands = _resource_conflict_get_node_resource_demand($conflicting_node);
    // select the resources that both this node and the other node demands
    $conflicting_resources = array();
  foreach ($other_demands as $other_demand) {
    foreach ($our_demands as $our_demand) {
      if ($our_demand['target_type'] == 'taxonomy_term' && $other_demand['target_type'] == 'user') {
        //$entities = db_query('SELECT DISTINCT entity_id FROM field_data_field_user_groups WHERE field_user_groups_tid=:tid', array(':tid' => $our_demand['target_id']));
        $entities = db_query('SELECT DISTINCT users.uid AS uid 
          FROM {users} users 
          INNER JOIN {field_data_field_user_groups} field_data_field_user_groups 
          ON users.uid = field_data_field_user_groups.entity_id 
          AND (field_data_field_user_groups.entity_type = \'user\') 
          WHERE (( ( users.status <> \'0\') AND (field_data_field_user_groups.field_user_groups_tid = :tid ) ))', array(':tid' => $our_demand['target_id']));
        foreach ($entities as $entity) {
          if ($entity->uid == $other_demand['target_id']) {
            $conflicting_user = reset(entity_load('user', array($other_demand['target_id'])));
            $conflicting_term = reset(entity_load('taxonomy_term', array($our_demand['target_id'])));
            $conflicting_resources_soft[] = array(
              'id'  =>  entity_id('user', $conflicting_user), 
              'label' => entity_label('user', $conflicting_user),
              'type' => 'user',
              'uri' => entity_uri('user', $conflicting_user),
              'term' => entity_label('taxonomy_term', $conflicting_term),
              'indcall' => $conflicting_node->nid,
              'grpcall' => $node->nid,
            );
          }
        }
      }
      if ($other_demand['target_type'] == 'taxonomy_term' && $our_demand['target_type'] == 'user') {
        //$entities = db_query('SELECT DISTINCT entity_id FROM field_data_field_user_groups WHERE field_user_groups_tid=:tid', array(':tid' => $other_demand['target_id']));
        $entities = db_query('SELECT DISTINCT users.uid AS uid 
          FROM {users} users 
          INNER JOIN {field_data_field_user_groups} field_data_field_user_groups 
          ON users.uid = field_data_field_user_groups.entity_id 
          AND (field_data_field_user_groups.entity_type = \'user\')  
          WHERE (( ( users.status <> \'0\') AND (field_data_field_user_groups.field_user_groups_tid = :tid ) ))', array(':tid' => $other_demand['target_id']));
        foreach ($entities as $entity) {
          if ($entity->uid == $our_demand['target_id']) {
            $conflicting_user = reset(entity_load('user', array($our_demand['target_id'])));
            $conflicting_term = reset(entity_load('taxonomy_term', array($other_demand['target_id'])));
            $conflicting_resources_soft[] = array(
              'id'  =>  entity_id('user', $conflicting_user), 
              'label' => entity_label('user', $conflicting_user),
              'type' => 'user',
              'uri' => entity_uri('user', $conflicting_user),
              'term' => entity_label('taxonomy_term', $conflicting_term),
              'indcall' => $node->nid,
              'grpcall' => $conflicting_node->nid,
            );
          }
        }
      }

      // display the error message for each soft conflict
      if (isset($conflicting_resources_soft)) {
        foreach ($conflicting_resources_soft as $conflicting_resource) {
          $date_field = variable_get('rc_date_field_' . $conflicting_node->type, FALSE);
          if (strpos($date_field, 'field_', 0) === 0) {
            $type = DATE_ISO;
            $startobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value']);
            $start = $startobj->format('Y-m-d H:i');
            $endobj =  new DateObject($conflicting_node->{$date_field}['und'][0]['value2']);
            $end = $endobj->format('Y-m-d H:i');
          }
          else {
            $start = format_date($conflicting_node->event_start, 'Y-m-d H:i');
            $end = format_date($conflicting_node->event_end, 'Y-m-d H:i');
          }
          $error = t('<a href="@resource-url">%resource</a> is a part of group %group, and is called for <a href="@booker-url">%booker</a> from %start to %end. They have been excused from the group rehearsal.',
            array(
              '@booker-url' => url('node/' . $conflicting_node->nid),
              '%booker' => $conflicting_node->title,
              '%group' => $conflicting_resource['term'],
              '@resource-url' => url($conflicting_resource['uri']['path'], $conflicting_resource['uri']['options']),
              '%resource' => $conflicting_resource['label'],
              '%start' => $start,
              '%end' => $end,
            )
          );

          drupal_set_message($error, 'warning');

        }

        // Delete any existing conflicts, and create a conflict node to record the conflict
        $entities = db_query('SELECT node.nid AS nid 
          FROM node
          LEFT JOIN {field_data_field_conflict_grp_call} field_data_field_conflict_grp_call ON node.nid = field_data_field_conflict_grp_call.entity_id AND (field_data_field_conflict_grp_call.entity_type = \'node\' AND field_data_field_conflict_grp_call.deleted = 0)
          LEFT JOIN {field_data_field_conflict_ind_call} field_data_field_conflict_ind_call ON node.nid = field_data_field_conflict_ind_call.entity_id AND (field_data_field_conflict_ind_call.entity_type = \'node\' AND field_data_field_conflict_ind_call.deleted = 0)
          LEFT JOIN {field_data_field_conflict_usr} field_data_field_conflict_usr ON node.nid = field_data_field_conflict_usr.entity_id AND (field_data_field_conflict_usr.entity_type = \'node\' AND field_data_field_conflict_usr.deleted = 0)
          WHERE (( (node.status = 1 AND node.type  = \'conflict\') AND ((field_data_field_conflict_grp_call.field_conflict_grp_call_target_id = :grp AND field_data_field_conflict_ind_call.field_conflict_ind_call_target_id = :ind) OR (field_data_field_conflict_grp_call.field_conflict_grp_call_target_id = :ind AND field_data_field_conflict_ind_call.field_conflict_ind_call_target_id = :grp)) AND (field_data_field_conflict_usr.field_conflict_usr_target_id = :usr) ))', 
          array(
            ':grp' => $conflicting_resource['grpcall'],
            ':ind' => $conflicting_resource['indcall'],
            ':usr' => $conflicting_resource['id']
          )
        );

        foreach ($entities as $entity) {
          node_delete($entity->nid);
        }
        $cnode = new stdClass();
        $cnode->type = 'conflict';
        $cnode->title = $conflicting_resource['label'] . ' excused from ' . $conflicting_resource['term'] . ' call for ' . $conflicting_node->title; 
        $cnode->language = LANGUAGE_NONE;
        $cnode->field_conflict_grp_call[$cnode->language][0]['target_id'] = $conflicting_resource['grpcall'];
        $cnode->field_conflict_usr[$cnode->language][0]['target_id'] = $conflicting_resource['id'];
        $cnode->field_conflict_ind_call[$cnode->language][0]['target_id'] = $conflicting_resource['indcall'];
        node_save($cnode);
        }
      } 
    }
  }
}

/** 
 * Delete any conflicts when this node is deleted
 * Implements hook_node_delete().
 */

function resource_conflict_node_delete($node) {
  if ($node->type == 'call') {
    $entities = db_query('SELECT node.nid AS nid 
      FROM node
      LEFT JOIN {field_data_field_conflict_grp_call} field_data_field_conflict_grp_call ON node.nid = field_data_field_conflict_grp_call.entity_id AND (field_data_field_conflict_grp_call.entity_type = \'node\' AND field_data_field_conflict_grp_call.deleted = 0)
      LEFT JOIN {field_data_field_conflict_ind_call} field_data_field_conflict_ind_call ON node.nid = field_data_field_conflict_ind_call.entity_id AND (field_data_field_conflict_ind_call.entity_type = \'node\' AND field_data_field_conflict_ind_call.deleted = 0)
      LEFT JOIN {field_data_field_conflict_usr} field_data_field_conflict_usr ON node.nid = field_data_field_conflict_usr.entity_id AND (field_data_field_conflict_usr.entity_type = \'node\' AND field_data_field_conflict_usr.deleted = 0)
      WHERE (( (node.status = 1 AND node.type  = \'conflict\') AND (field_data_field_conflict_grp_call.field_conflict_grp_call_target_id = :me OR field_data_field_conflict_ind_call.field_conflict_ind_call_target_id = :me) ))',
        array(
          ':me' => $node->nid
        )
      );

    foreach ($entities as $entity) {
      node_delete($entity->nid);
    }
  } 
}

/**
 * Implements hook_form_alter().
 */
function resource_conflict_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'node_type_form') {
    $requirements = array();

    $type = (isset($form['old_type']) && isset($form['old_type']['#value'])) ? $form['old_type']['#value'] : NULL;

    $form['resource_conflict_set'] = array(
      '#type' => 'fieldset',
      '#title' => t('Resource Conflict'),
      '#collapsible' => TRUE,
      '#group' => 'additional_settings',
    );

    // The user is adding a new content type
    if ($type == NULL) {
      $form['resource_conflict_set']['rc_info'] = array(
        '#prefix' => '<p>',
        '#suffix' => '</p>',
        '#value' => t('To set up this content type for conflict checking, first event-enable the type, or add a Date CCK field with required start and end dates. Then, add at least one Node Reference field linked to the content type of items you would like to be able to book. When all of the conditions have been met, this section will be enabled for configuration.'),
      );
      return;
    }
    $date_fields = array();
    if ($type != NULL) {
      $fields = field_info_instances('node', $type);
      foreach ($fields as $fieldname => $field) {
          $fieldinfo = field_info_field($fieldname);
        if (isset($field['display']['default']['module'])&&($field['display']['default']['module'] == 'date')&&($field['required'] == 1)) {
          if ($fieldinfo['settings']['todate'] == 'required' ) {
            $date_fields[$fieldname] = $field['label'];
          }
        }
        elseif (($fieldinfo['type'] == 'entityreference') || ($fieldinfo['type'] == 'taxonomy_term_reference')) {
          $nodereference_fields[$fieldname] = $field['label'];
        }
      }
    }

    if (empty($nodereference_fields)) {
      $requirements['entityreference'] = t('At least one Entity Reference field must be added to this content type.');
    }

    if (empty($date_fields)) {
      $requirements['date_api'] = t('This content type does not contain any suitable Date fields. Please add at least one Date field with required start and end dates if you wish to use Resource Conflict with the Date module.');
    }

    if (!empty($requirements)) {
      _resource_conflict_disable($type, TRUE);
      $form['resource_conflict_set']['requirements'] = array(
        '#prefix' => '<p>' . t('The following requirements for Resource Conflict have not been met:') . '</p><ol>',
        '#suffix' => '</ol>',
        '#weight' => -10,
      );
      foreach ($requirements as $component => $error) {
        $form['resource_conflict_set']['requirements'][$component] = array(
          '#prefix' => '<li>',
          '#suffix' => '</li>',
          '#value' => $error,
        );
      }
    }
    else {
      $form['resource_conflict_set']['rc_type'] = array(
        '#type' => 'checkbox',
        '#title' => t('Enable resource conflict checking for this content type'),
        '#default_value' => variable_get('rc_type_' . $type, 0),
        '#weight' => -8,
      );

      $form['resource_conflict_set']['rc_date_field'] = array(
        '#type' => 'select',
        '#title' => t('Field to use as the date for conflict checks'),
        '#options' => $date_fields,
        '#multiple' => FALSE,
        '#default_value' => variable_get('rc_date_field_' . $type, FALSE),
        '#description' => t("Select the date field to use to check for resource conflicts."),
      );

      $form['resource_conflict_set']['rc_reference_fields'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Fields to check for conflicts'),
        '#options' => $nodereference_fields,
        '#default_value' => variable_get('rc_reference_fields_' . $type, array()),
        '#description' => t("Select the resources which can't be booked at the same time."),
      );
    }

    //set custom validation and submit callbacks
    $form['#validate'][] = 'resource_conflict_form_validate';
    $form['#submit'][] = 'resource_conflict_form_submit';
  }
}

/**
 * Validate the node_type_form
 */
function resource_conflict_form_validate($form, &$form_state) {
  if ($form_state['values']['form_id'] == 'node_type_form') {
    if (isset($form_state['values']['rc_type'])&&$form_state['values']['rc_type']) {
      $resource_selected = FALSE;
      foreach ($form_state['values']['rc_reference_fields'] as $field) {
        if ($field) {
          $resource_selected = TRUE;
          break;
        }
      }
      if (!$resource_selected) {
        form_set_error('rc_reference_fields', t("At least one resource field must be set if conflict handling is enabled."));
      }
    }
  }
}

/**
 * Submit the node_type_form
 */
function resource_conflict_form_submit($form, &$form_state) {
  $type = $form_state['values']['type'];
  $old_type = $form_state['values']['old_type'];
  $conflict_types = variable_get("rc_types", array());

  //unset old entry
  if (!empty($old_type)) {
    $key = array_search($old_type, $conflict_types);
    unset($conflict_types[$key]);
  }

  //make new entry if this type is conflict handled
  if (isset($form_state['values']['rc_type'])&&($form_state['values']['rc_type'])) {
    $conflict_types[] = $type;
  }

  variable_set("rc_types", $conflict_types);
}

/**
 * Get the conflict enabled types
 *
 * @return
 *   An array of type names
 */
function _resource_conflict_get_conflict_enabled_types() {
  $conflict_types = variable_get("rc_types", array());
  return $conflict_types;
}

/**
 * Get a conflict enabled node's resource demand
 *
 * @param $node
 *   The node which resurce demand will be returned
 * @return
 *   An array with keys of the node ID's, values of true
 */
function _resource_conflict_get_node_resource_demand($node) {
  $type = $node->type;
  $reference_fields = variable_get('rc_reference_fields_' . $type, array());
  $demand = array();
  foreach ($reference_fields as $reference_field) {
    $fieldinfo = field_info_field($reference_field);
    if (isset($node->{$reference_field}['und'])) {
      $references = $node->{$reference_field}['und'];
      foreach ($references as $key => $reference) {
        /**
         * Check to see if any referencable resources exist. If they don't, file
         * an error. This only matters when the nodereference field is set to
         * required, otherwise this code doesn't get called at all. We have to
         * file the error against the fake 'no_resources' element as CCK files
         * it's own "Illegal choice" error before we get called.
         */
        if (isset($reference['target_id'])) { 
          $rid = $reference['target_id'];
          $target_type = $fieldinfo['settings']['target_type'];
        }
        elseif (isset($reference['tid'])) {
          $rid = $reference['tid'];
          $target_type = 'taxonomy_term';
        };
        if (is_numeric($rid)) {
          $demand[] = array(
            'target_id' => $rid, 
            'target_type' => $target_type,
          );
        }
        elseif (($reference != 'Add another item') && ($rid != '')) {
          form_set_error('no_resources', t('No bookable resources have been created. Please create resources to book before attempting to create a resource booking.'));
        }
      }
    }
  }
  //form_set_error('Debug', 'everything is fine, but you cannot move on for test purposes');
  return $demand;
}

/**
 * Determine if any nodes conflict between the specified dates using Date API.
 *
 * @param $date_start
 *   The start date of the date to check
 * @param $date_end
 *   The end date of the date to check.
 * @return
 *   An array of node ID's
 */
function _resource_conflict_overlaps_from_date($date_start, $date_end) {
  // Make the default type to DATE_ISO.
  $type = DATE_ISO;
  $date_startobj = New DateObject($date_start, 'GMT');
  $date_endobj   = New DateObject($date_end, 'GMT');

  return _resource_conflict_get_overlaps($date_startobj, $date_endobj);
}

/**
 * Determine if any nodes conflict between the specified dates using Event.
 *
 * @param $event_start
 *   The start date of the event to check
 * @param $event_end
 *   The end date of the event to check.
 * @return
 *   An array of node ID's
 */
function _resource_conflict_overlaps_from_event($event_start, $event_end) {
  $start = date_make_date($event_start, 'GMT', DATE_UNIX);
  $end = date_make_date($event_end, 'GMT', DATE_UNIX);
  return _resource_conflict_get_overlaps($start, $end);
}

/**
 * Determine if any conflict enabled nodes overlap the specified times
 *
 * 1. $start is within the event time
 * 2. $end end is within the event time
 * 3. The event encompasses $start and $end
 * 4. Allow the end of one event to occur at the start of the next
 *
 * @param $start
 *   The start time of events to search as dateAPI object
 * @param $end
 *   The end time of events to search as dateAPI object
 * @return
 *   An array of node ID's
 */
function _resource_conflict_get_overlaps($start, $end) {
  $date_start = $start->format(DATE_FORMAT_DATETIME);
  $date_end = $end->format(DATE_FORMAT_DATETIME);
  $rows = array();
  $conflict_types = _resource_conflict_get_conflict_enabled_types();
  foreach ($conflict_types as $type) {
    $date_field = variable_get('rc_date_field_' . $type, FALSE);
    if (strpos($date_field, 'field_', 0) === 0) {
      $date_table = '{' . 'field_data_' . $date_field . '}';
      $start_field_name = $date_field . '_value';
      $end_field_name = $date_field . '_value2';
      $query = "SELECT DISTINCT {node}.nid FROM {node} INNER JOIN $date_table date_table ON {node}.vid = date_table.revision_id
       WHERE(:date_start >= date_table.$start_field_name AND :date_start < date_table.$end_field_name)
       OR(:date_end > date_table.$start_field_name AND :date_end <= date_table.$end_field_name)
       OR(:date_start <= date_table.$start_field_name AND :date_end >= date_table.$end_field_name)";
      $result = db_query($query, array(':date_start' => $date_start, ':date_end' => $date_end));

      // Create an array of all of the results
      while ($row = $result->fetchAssoc()) {
        $rows[] = $row['nid'];
      }
    }
    elseif ($date_field == 'event') {
      // @todo this is not yet tested under drupal7.
      // Event enabled.
      $query = "SELECT DISTINCT nid FROM {event} WHERE (%d >= event_start AND %d < event_end)
       OR (%d > event_start AND %d <= event_end)
       OR (%d <= event_start AND %d >= event_end)";
      $result = db_query("SELECT DISTINCT nid FROM {event} WHERE (%d >= :(%d AND %d < :%d
       OR (%d > :(%d AND %d <= :%d
       OR (%d <= :(%d AND %d >= :%d", array(':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, ':(%d' => event_start, ':%d' => event_end, '' => $event_start, '' => $event_start, '' => $event_end, '' => $event_end, '' => $event_start, '' => $event_end));

      // Create an array of all of the results
      while ($row = db_fetch_array($result)) {
        $rows[] = $row['nid'];
      }
    }
  }
  return array_unique($rows);
}

/**
 * Disable resource conflict for a type, optionally notifying the user. A
 * message is always logged in the Drupal log. If the content type is not
 * conflict-enabled, nothing is changed.
 *
 * @param $type
 *  The content type to disable.
 *
 * @param $display
 *   If TRUE, display the message with drupal_set_message().
 */
function _resource_conflict_disable($type, $display = FALSE) {
  // If the requirements are no longer met, disable resource checking and
  // alert the site administrator.
  if (variable_get('rc_type_' . $type, FALSE)) {
    variable_del('rc_type_' . $type);
    $msg = t('Resource Conflict has been disabled for the %type content type as the requirements for it are no longer met.', array('%type' => $type));

    if ($display) {
      drupal_set_message($msg, 'Resource Conflict');
    }
    watchdog('rsrc conflict', $msg, WATCHDOG_WARNING);
  }
}

/**
 *  A function to display the database value for the date object
 *
 *  @param $date - the date object
 *  @param $format - DATE_UNIX or DATE_ISO, the type of value to display
 *  @param $type - 'db' or 'local', the date value to display
 */
if (!function_exists('date_show_value')) {
  function date_show_value($date, $type = 'db', $format = DATE_ISO) {
    if ($format == DATE_UNIX) {
      return $date->$type->timestamp;
    }
    else {
      return $date->$type->iso;
    }
  }
}

