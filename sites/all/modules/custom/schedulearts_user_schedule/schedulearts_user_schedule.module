<?php
/**
 * @file
 * Gather user‘s personal schedule and send in an email.
 */

/**
 * Implements hook_menu().
 */
function schedulearts_user_schedule_menu() {
  $items['schedule/%user/%node'] = array(
    'title' => 'Personal Schedule Email Format',
    'page callback' => 'schedulearts_user_schedule_render',
    'page arguments' => array(1, 2),
    'access arguments' => array('access content'),
  );
  return $items;
}
/**
 * Implements hook_flag_flag().
 *
 * When a flagging action happens, and the flag is a schedule_approved flag,
 * we send the schedule e-mail for them.
 * @see hook_flag_flag().
 */
function schedulearts_user_schedule_flag_flag($flag, $content_id, $account, $flagging) {
  if ($flag->name === 'schedule_approved') {
    // Send email to group members.
    $node = node_load($content_id);
    if (isset($node->field_sched_groups['und'])) {
      foreach ($node->field_sched_groups['und'] as $term_entry ) {
        $tid_array[] = $term_entry['tid'];
      }
      $tid_string = implode(',', $tid_array);
      $users = db_query('SELECT DISTINCT users.uid AS uid
        FROM users
        INNER JOIN field_data_field_user_groups
        ON users.uid = field_data_field_user_groups.entity_id
        AND field_data_field_user_groups.entity_type = \'user\'
        WHERE (( field_data_field_user_groups.field_user_groups_tid IN ( :tid )  ))', array(':tid' => $tid_string));
      foreach ($users as $user) {
        $userfields = reset(entity_load('user', array($user->uid)));
        
        // Build the actual email
        $sched_from = variable_get('system_mail', 'info@schedulearts.com');
        $sched_to = $userfields->mail;
        $sched_to_name = $userfields->name;
        
        // Get rendered mail contents
        $mail_contents = schedulearts_user_schedule_render($user, $node, TRUE);
        $allowed_tags = array('a', 'em', 'i', 'strong', 'b', 'br', 'p', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr');
        $mail_contents['body'] = drupal_html_to_text($mail_contents['body'], $allowed_tags);

        $mailtoken = microtime();
        $mailid = 'schedulearts' . '_' . $mailtoken;
        $message = array(
          'id' => $mailid,
          'to' => $sched_to,
          'subject' => $mail_contents['subject'],
          'body' => $mail_contents['body'],
          'headers' => array(
            'From' => $sched_from,
            'Sender' => $sched_from,
            'Return-Path' => $sched_from
          ),
        );
        $system = drupal_mail_system('schedulearts', $mailtoken);
        $message = $system->format($message);

        if ($system->mail($message)) {
          drupal_set_message(t('Schedule has been sent to its recipients'));
        }
        else {
          t('Mail sending failed.');
        }
      }
    }
  }
}
/**
 * Render the calls in a dete range of a given schedule for a user.
 *
 * @param stdClass $account
 * A standard user object the schedule is displayed for.
 * @param stdClass $node
 * The node that defines the range and groups of the schedule. 
 */
function schedulearts_user_schedule_render($account, $node, $mail_layout = FALSE) {
  if ($node->type !== 'schedule' || !$account) {
    return '';
  }
  $schedule_date = reset(field_get_items('node',$node,'field_sched_date'));
  $date_from = strtotime($schedule_date['value']);
  $date_until = strtotime($schedule_date['value2']);

  // Get the output for subject.
  $output['subject'] = theme('schedulearts_user_schedule_subject',
    array(
      'username' => $account->name,
      'date_from' => $date_from,
      'date_until' => $date_until,
    )
  );
  $body = reset(field_get_items('node', $node, 'body'));
  $output['body'] = theme('schedulearts_user_schedule_body', 
    array('account' => $account, 'date_from' => $date_from, 'date_until' => $date_until));

  $output['author_comment'] = drupal_render(field_view_value('node', $node, 'body', $body));

  // Print the days.
  $day = 60 * 60 * 24;
  $date = $date_from;
  while ($date <= $date_until) {
    $output["date_{$date}"] = '<div>'
      . schedulearts_user_schedule_print_date($date, $account) 
      . '</div>';
    $date += $day;
  }

  if (!$mail_layout){
    return implode("\n", $output);
  }
  else {
    $return = array('subject' => array_shift($output), 'body' => $output);
    return $return;
  }
}
/**
 * IMplements hook_theme().
 */
function schedulearts_user_schedule_theme() {
  return array(
    'schedulearts_user_schedule_subject' => array(
      'variables' => array('username' => '', 'date_from' => 0, 'date_until' => 0),
    ),
    'schedulearts_user_schedule_body' => array(
      'variables' => array('account' => NULL, 'date_from' => 0, 'date_until' => 0),
    ),
    'schedulearts_user_schedule_table_render' => array(
      'variables' => array('calls' => array()),
    ),
  );
}

/**
 * Theme function for subject.
 *
 * @param $data
 *   Array containing:
 *    username - username,
 *    date_from - the selected calls start date,
 *    date_until - the selected calls end date.
 * @return string
 *   The output string for subject.
 */
function theme_schedulearts_user_schedule_subject($variables) {
  $date_from_formatted = date('l n/j/Y', $variables['date_from']);
  $date_until_formatted = date('l n/j/Y', $variables['date_until']);
  return t("@username 's personal schedule for @date_from_formatted to @date_until_formatted",
    array(
      '@username' => $variables['username'],
      '@date_from_formatted' => $date_from_formatted,
      '@date_until_formatted' => $date_until_formatted,
    )
  );
}
/**
 * Theme function for body.
 *
 * @param $data
 *   Array containing:
 *    uid - user ID
 *    username - username,
 *    date_from - the selected calls start date,
 *    date_until - the selected calls end date.
 * @return string
 *   The output string for body.
 */
function theme_schedulearts_user_schedule_body($variables) {
  global $base_url;
  $output = '';
  $date_from_formatted = date('l n/j/Y', $variables['date_from']);
  $date_until_formatted = date('l n/j/Y', $variables['date_until']);
  $output .= '<h2>' . t('Dear @name_full,', array('@name_full' => $variables['account']->name)) . '</h2>';
  $mycalendar_path = url("user/{$variables['account']->uid}/mycal", array('absolute' => TRUE));
  $mycalendar_link = l($mycalendar_path, $mycalendar_path);
  $output .= '<p>' . t('Below is your schedule for @date_from_formatted to @date_until_formatted. You can also view your schedule online at !mycalendar_link', array(
      '@date_from_formatted' => $date_from_formatted,
      '@date_until_formatted' => $date_until_formatted,
      '!mycalendar_link' => $mycalendar_link,
    )
  ) . '</p>';
  return $output;
}

/**
 * Menu callback; Output the schedule tables.
 *
 * @param $date
 *   The date in Y-m-d format.
 * @param $uid
 *   The user whose calls should be listed.
 * @return string
 *   The rendered page.
 */
function schedulearts_user_schedule_print_date($date, $account) {
  $day = 60 * 60 * 24;
  $date_until = $date + $day;
  $schedule_calls = _schedulearts_user_schedule_get_calls($date, $date_until);
  $output = array();
  if (!empty($schedule_calls)){
    $output[] = '<h2>' . date('l n/j/Y', $date) . '</h2>';   
    $output[] = theme('schedulearts_user_schedule_table_render', 
      array('calls' => $schedule_calls));
  }
  return implode("\n", $output);
}

/**
 * The theme function for the table of selected calls.
 *
 * @param $uid
 *   The user id.
 * @param $date_from
 *   The selected calls start date.
 * @param $date_until
 *   The selected calls end date.
 * @return string
 *   The HTML output of the selected calls table.
 */
function theme_schedulearts_user_schedule_table_render($variables) {
  $output = '';
  // Render the HTML for each group.
  foreach ($variables['calls'] as $data) {
    $call = $data['call'];
    $event = $data['event'];
      $time_range = date('G:i', strtotime($call->call_date_from)) 
        . ' - ' . date('G:i', strtotime($call->call_date_until));
      $first_col = '<h3>' . $time_range . '</h3>';

      $second_col = '<h3>' . check_plain($call->call_title) . '</h3>';
      $second_col .= '<p>' . check_plain($call->call_body) . '</p>';
      $second_col .= '<p>' . check_plain($event->event_body) . '</p>';
      $call_groups = array();
      foreach($call->call_groups as $group) {
        $call_groups[] = check_plain(_schedulearts_user_schedule_get_term_name($group));
      }
      $call_individuals = array();
      foreach($call->call_individuals as $person) {
        $call_individuals[] = check_plain(_schedulearts_user_schedule_get_user_name($person));
      }

      $second_col .= '<p>' . implode(', ', $call_groups) . '</p>';
      $second_col .= '<p>' . implode(', ', $call_individuals) . '</p>';

      $third_col = '<h3>' . check_plain($event->event_location) . '</h3>';

      $rows[] = array($first_col, $second_col, $third_col);
  }
  // Render the table of calls.
  $output .= theme('table', array('rows' => $rows));
  return $output;
}

/**
 * Fetch all calls for given date interval.
 *
 * @param $date_from
 *   The selected interval start date.
 * @param $date_until
 *   The selected interval end date.
 * @return mixed
 *   Returns an array with all calls for selected date interval.
 */
function _schedulearts_user_schedule_get_calls($date_from, $date_until, $account = NULL) {
  // Convert the date format to DATATIME format.
  $date_from = date('Y-m-d G:i:s', $date_from);
  $date_until = date('Y-m-d G:i:s', $date_until);
  $query = db_select('node', 'n');
  $query->distinct();
  // Add relevant tables to the node table.
  $query->leftJoin('field_data_field_event_groups_tax', 'feg', 'feg.entity_id = n.nid');
  $query->leftJoin('field_data_field_event_individuals', 'fei', 'fei.entity_id = n.nid');
  $query->leftJoin('field_data_field_event_date', 'edv', 'edv.entity_id = n.nid');
  $query->leftJoin('field_data_body', 'cb', 'cb.entity_id = n.nid');
  $query->leftJoin('field_data_field_call_parent_event', 'cpe', 'cpe.entity_id = n.nid');
  $query->leftjoin('node', 'en', 'cpe.entity_id = en.nid');
  // Add relevant fields.
  $query->addField('n', 'nid', 'call_nid');
  $query->addField('n', 'title', 'call_title');
  //$query->addField('feg', 'field_event_groups_tax_tid', 'call_group');
  //$query->addField('fei', 'field_event_individuals_target_id', 'call_individual');
  $query->addField('edv', 'field_event_date_value', 'call_date_from');
  $query->addField('edv', 'field_event_date_value2', 'call_date_until');
  $query->addField('cb', 'body_value', 'call_body');
  $query->addField('cpe', 'field_call_parent_event_target_id', 'call_parent_event');
  // Select all calls for given time interval.
  $query->condition('n.type', 'call', '=');
  $query->condition('edv.field_event_date_value', $date_from, '>');
  $query->condition('edv.field_event_date_value', $date_until, '<');
  // Select only for a given user.
  if ($account) {
    $account_groups = _schedulearts_user_schedule_get_user_groups($account); 
    $or_statement = db_or()->condition('fei.field_event_individuals_target_id',$account->uid);
    if (!empty($account_groups)) {
      $or_statement->condition('feg.field_event_groups_tax_tid', $account_groups);
    }
    $query->condition('feg.field_event_groups_tax_tid', $account_groups);
  }

  $query->orderBy('edv.field_event_date_value', 'asc');

  $result = $query->execute()->fetchAll();
  // Attach relevant fields from parent event entity.
  foreach ($result as $key => $row) {
    // Extract attached groups and individuals‘ data.
    $call =node_load($row->call_nid);
    $persons = (array) field_get_items('node', $call, 'field_event_individuals');
    foreach($persons as $person) {
      $row->call_individuals[] = $person['target_id'];
    }
    $groups = (array) field_get_items('node', $call, 'field_event_groups_tax');
    foreach($groups as $group) {
      $row->call_groups[] = $group['tid'];
    }
    // Extract parent event data.
    $event_id = $row->call_parent_event;
    $event_entity = entity_load_single('node', $event_id);
    $event_entity_wrapper = entity_metadata_wrapper('node', $event_entity);

    $event_body = $event_entity_wrapper->body->value();
    $event_location = $event_entity_wrapper->field_event_location->value();

    $event = new stdClass();
    $event->event_body = $event_body['value'];
    $event->event_location = $event_location->title;

    $result[$key] = array('call' => $row, 'event' => $event);
  }
  return $result;
}
/**
 * Return an array with user taxonomy groups term ID-s.
 *
 * @param $uid
 *   The user id.
 * @return array
 *   Array with user taxonomy group tid.
 */
function _schedulearts_user_schedule_get_user_groups($account) {
  $account_wrapper = entity_metadata_wrapper('user', $account);
  $account_groups = array();
  foreach ($account_wrapper->field_user_groups->value() as $group) {
    $account_groups[] = $group->tid;
  }
  return $account_groups;
}
/**
 * Fetch the user name from user id.
 *
 * @param $uid
 *   The user ID.
 * @return mixed
 *   The username of the user.
 */
function _schedulearts_user_schedule_get_user_name($uid) {
  $output = '';
  if ($uid != NULL) {
    $account = array_shift(entity_load('user', array($uid)));
    $output = $account->name;
  }
  return $output;
}
/**
 * Fetch the term name of a term id.
 *
 * @param $tid
 *   The term ID.
 * @return string
 *   The term name.
 */
function _schedulearts_user_schedule_get_term_name($tid) {
  $output = '';
  if ($tid != NULL) {
    $term = taxonomy_term_load($tid);
    $output = $term->name;
  }
  return $output;
}
