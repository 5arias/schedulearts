<?php

/**
 * Implements hook_views_api().
 */
function schedulearts_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_flag_link().
 *
 * When Flag uses a link type provided by this module, it will call this
 * implementation of hook_flag_link(). 
 * This implementation sends a schedule email in response to the schedule flag
 *
 * @param $flag
 *   The full flag object of for the flag link being generated.
 * @param $action
 *   The action this link will perform. Either 'flag' or 'unflag'.
 * @param $content_id
 *   The ID of the node, comment, user, or other object being flagged.
 * @return
 *   An array defining properties of the link.
 */
function schedulearts_flag($action, $flag, $content_id, $account) {
  if ($action == 'flag' && $flag->name == 'schedule_approved') {
    // Send email to group members
    $node = node_load($content_id);
    if (isset($node->field_sched_groups['und'])) {
      foreach ($node->field_sched_groups['und'] as $term_entry ) {
        $tid_array[] = $term_entry['tid'];
      }
      $tid_string = implode(',', $tid_array); 
      $users = db_query('SELECT DISTINCT users.uid AS uid 
        FROM users 
        INNER JOIN field_data_field_user_groups 
        ON users.uid = field_data_field_user_groups.entity_id 
        AND field_data_field_user_groups.entity_type = \'user\' 
        WHERE (( field_data_field_user_groups.field_user_groups_tid IN ( :tid )  ))', array(':tid' => $tid_string));
      foreach ($users as $user) {
        $userfields = reset(entity_load('user', array($user->uid)));
        // Build the view
        $allowed_tags = array('a', 'em', 'i', 'strong', 'b', 'br', 'p', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr');
        $view = views_get_view('taxonomy_term_calendar' , TRUE);
        $arg[] = $node->field_sched_date['und']['0'];
        $arg[] = $userfields->uid;
        $views_result = $view->preview('page_2', $arg);
        $sched_view_output = drupal_html_to_text($views_result, $allowed_tags);

        $sched_from = variable_get('system_mail', 'info@schedulearts.com');
        $sched_to = $userfields->mail;
        $sched_to_name = $userfields->name;
        $sched_daterng = $node->field_sched_date['und']['0']['value'] . ' - ' . $node->field_sched_date['und']['0']['value2'];
        $sched_subj = 'Your personal schedule for ' . $sched_daterng;
        if ($node->body['und']) $sched_note = $node->body['und']['0']['value'];
        $sched_body = "Dear $sched_to_name,
      
  $sched_note 

  Here is your schedule for the period $sched_daterng. You can see this in a friendlier format online at: 
          
        $GLOBALS[base_url]/user/$user->uid/mycal
          
          
  *** MY SCHEDULE FOR $sched_daterng ***
  $sched_view_output

  Thanks!";


        $mailtoken = microtime();
        $mailid = 'schedulearts' . '_' . $mailtoken;
        $message = array(
          'id' => $mailid,
          'to' => $sched_to,
          'subject' => $sched_subj,
          'body' => array($sched_body),
          'headers' => array(
            'From' => $sched_from,
            'Sender' => $sched_from,
            'Return-Path' => $sched_from
          ),
        );
        $system = drupal_mail_system('schedulearts', $mailtoken);
        $message = $system->format($message);

        if ($system->mail($message)) {
        }
      }
    }
  }
}

/*
 * Implements hook_form_alter().
 */

function schedulearts_form_alter(&$form, &$form_state, $form_id) {
  // tweaks to user-groups View
	
  // make the search field bigger
  if($form_id == 'views_exposed_form') {
    $form['field_user_searchable_name_value']['#size'] = 60;
		
		//set select size to one
		foreach ($form as $key => $element) {
			if ($key != 'field_user_searchable_name_value' && isset($element['#type']) && $element['#type'] == 'select') {
				$form[$key]['#size'] = 1;
			}
		}
		
  }
  // Set the order of VBO options 
  if($form_id == 'views_form_user_groups_page') {
    $form['select']['operation']['#options'] = array(
      '0' => '- Choose an operation -',
      'action::views_bulk_operations_modify_action' => 'Add to Groups',
      'rules_component::rules_promote_to_company_administrator' => 'Promote to company admin',
      'rules_component::rules_demote_from_company_administrator' => 'Demote from company admin',
      'action::user_block_user_action' => 'De-Activate',
      'rules_component::rules_unblock_a_user' => 'Activate',
      'action::views_bulk_operations_delete_item' => 'Delete',
    );
  }

  // Tweaks to the Call people interface
  if ($form_id == 'call_node_form')  {
    // Set the parent event from POST or value in edited node
    if (isset($_POST['edit'])){
      $form['field_call_parent_event']['und']['#default_value']['0'] = $_POST['edit']['field_call_parent_event']['und'];
      $parent_event_id = $_POST['edit']['field_call_parent_event']['und'];
    }
    elseif (isset($form['#node']->field_call_parent_event['und']['0']['target_id'])) {
      $parent_event_id = $form['#node']->field_call_parent_event['und']['0']['target_id'];
    }

    if (isset($parent_event_id)) {
      // Disable the parent event field
      $form['field_call_parent_event']['und']['#disabled'] = TRUE;

      // Get the parent event object
      $parent_event = reset(entity_load('node', array($parent_event_id)));

      // Set the default dates
      $form['field_event_date']['und']['0']['#default_value']['value'] = $parent_event->field_event_date['und']['0']['value'];
      $form['field_event_date']['und']['0']['#default_value']['value2'] = $parent_event->field_event_date['und']['0']['value2'];

      // Set the default repeat
      if (!empty($parent_event->field_event_date[LANGUAGE_NONE]['0']['rrule'])) {
        $form['field_event_date']['und']['0']['show_repeat_settings']['#default_value'] = '1';
        $form['field_event_date']['und']['0']['#default_value']['rrule'] = $parent_event->field_event_date['und']['0']['rrule'];
      }
        $form['field_event_date']['#after_build'][] = 'schedulearts_call_date_repeat_disable';

      // Limit available options in the dropdowns with custom after_build and validation calls
      $min_date = new DateObject($parent_event->field_event_date['und']['0']['value']);
      $max_date = new DateObject($parent_event->field_event_date['und']['0']['value2']);
      $form_state['#schedulearts']['parent_event'] = $parent_event;
      $form_state['#schedulearts']['min_date'] = $min_date;
      $form_state['#schedulearts']['max_date'] = $max_date;
      $form['field_event_date']['#after_build'][] = 'schedulearts_call_date_limit';
      $form['field_event_date']['#element_validate'][] = 'schedulearts_call_date_validate';

      // Set the field description
      $form_state['field']['field_event_date']['und']['instance']['description'] = t('Calls must be inside the event timerange of %from - %to.', array('%from' => date_format_date($min_date, 'custom', 'g:i a'), '%to' => date_format_date($max_date, 'custom', 'g:i a')));
    }
    else {
      drupal_set_message(t('Notice: Calls are designed to be added as a part of an Event, but no parent Event was detected.'), 'warning');
    }
  }

  // Tweaks to the Add Production form
  if ($form_id == 'production_node_form') {
    // Limit available "group structures" to the top level of the vocabulary
    if (isset($form['field_group_structure']['und']['#options'])) {
      $new_opts = '';
      foreach ($form['field_group_structure']['und']['#options'] as $tid => $title) {
        if (!taxonomy_get_parents($tid)) {
          $new_opts[$tid] = $title;
        }
      }
      if ($new_opts) {
        $form['field_group_structure']['und']['#options'] = $new_opts;
      }
    }
    else {
      drupal_set_message(t('WARNING: No standard Group structures detected. Groups will not be auto-populated for this Production.'), 'warning');
    }

    // Limit available "Seasons" to the top level of the vocabulary, too
    $new_opts = '';
    foreach ($form['field_season']['und']['#options'] as $tid => $title) {
      if (!taxonomy_get_parents($tid)) {
        $new_opts[$tid] = $title;
      }
    }
    if ($new_opts) {
      $form['field_season']['und']['#options'] = $new_opts;
    }
  }

  //Tweaks to the Add Master Calendar Event form
  if ($form_id == 'master_calendar_event_node_form') {
    $form['field_date']['#after_build'][] = 'schedulearts_mc_date_repeat_defaults';
    $form['field_prod_color']['#attributes']['class'][] = 'schedulearts-hidden';
    $form_state['schedulearts_redirect'] = 'master-calendar';
  }
  // Tweaks to the Event Type form
  if ($form_id == 'taxonomy_form_term' && ($form['#vocabulary']->vid == '6' || $form['#vocabulary']->vid == '4')) {
    $form['relations']['#attributes']['class'][] = 'schedulearts-hidden';
    // TO DO: add a color picker to this edit form
  }

  // Tweaks to the Create Event form
  if ($form_id == 'event_node_form') {
    // TODO: Date single day
    //array_unshift($form['#validate'], 'schedulearts_single_date_copy');
  }

  // Add custom redirect to node forms
  if (substr($form_id, -9) == 'node_form') {
    $form['actions']['submit']['#submit'][] = 'schedulearts_redirect_submit_handler';
  }
}

/*
 * Custom validation call to handle single day date fields
 */
function schedulearts_single_date_copy($form_element, &$form_state) {
  // TODO: make this work
}

/*
 * Custom form element after_build, manipulates date repeat defaults for MC Events
 */
function schedulearts_mc_date_repeat_defaults($form_element, &$form_state) {
  $form_element['und']['0']['show_todate']['#title'] = t('Add End Date');
  $form_element['und']['0']['show_todate']['#default_value'] = FALSE;
  $form_element['und']['0']['show_todate']['#checked'] = FALSE;
  return $form_element;
}

/* 
 * Custom submit handler to redirect the user after submission, since Rules redirect
 * breaks with Overlay
 */
function schedulearts_redirect_submit_handler($form, &$form_state) {
  if (isset($form_state['schedulearts_redirect'])) {
    $form_state['redirect'] = $form_state['schedulearts_redirect'];
  }
}

/*
 * Hide pre-set repeat fields
 */
function schedulearts_call_date_repeat_disable($form_element, &$form_state) {
  $form_element['#attributes']['class'][] = 'schedulearts-hidden-repeat';
  return $form_element;
}
/*
 * Limit select options in field_event_date on Call node forms
 */
function schedulearts_call_date_limit($form_element, &$form_state) {
  // set from date
  $min_date = $form_state['#schedulearts']['min_date'];
  $year = date_format_date($min_date, 'custom', 'Y');
  settype($year, "integer");
  $month_num = date_format_date($min_date, 'custom', 'n');
  $month = date_format_date($min_date, 'custom', 'M');
  $day = date_format_date($min_date, 'custom', 'j');
  settype($day, "integer");
  $form_element['und']['0']['value']['year']['#options'] = array($year => $year);
  $form_element['und']['0']['value']['month']['#options'] = array($month_num => $month);
  $form_element['und']['0']['value']['day']['#options'] = array($day => $day);

  // set to date
  $max_date = $form_state['#schedulearts']['max_date'];
  $year = date_format_date($max_date, 'custom', 'Y');
  settype($year, "integer");
  $month_num = date_format_date($max_date, 'custom', 'n');
  $month = date_format_date($max_date, 'custom', 'M');
  $day = date_format_date($max_date, 'custom', 'j');
  settype($day, "integer");
  $form_element['und']['0']['value2']['year']['#options'] = array($year => $year);
  $form_element['und']['0']['value2']['month']['#options'] = array($month_num => $month);
  $form_element['und']['0']['value2']['day']['#options'] = array($day => $day);

  // Apply CSS to hide the pre-set fields
  $form_element['#attributes']['class'][] = 'schedulearts-hidden-date';

  return $form_element;
}

/*
 * Custom validation to ensure that only valid dates are entered
 */
function schedulearts_call_date_validate($form_element, &$form_state, $form) {
  // Initialize variables; UNIX timestamps for all relevant times
  $min_date = $form_state['#schedulearts']['min_date'];
  $max_date = $form_state['#schedulearts']['max_date'];
  $entered_from = new DateObject($form_state['values']['field_event_date']['und']['0']['value']);
  $entered_to = new DateObject($form_state['values']['field_event_date']['und']['0']['value2']);
  $min_date_unix = date_format_date($min_date, 'custom', 'U');
  $max_date_unix = date_format_date($max_date, 'custom', 'U');
  $entered_from_unix = date_format_date($entered_from, 'custom', 'U');
  $entered_to_unix = date_format_date($entered_to, 'custom', 'U');
  
  if ($entered_from_unix < $min_date_unix || $entered_from_unix > $max_date_unix || $entered_to_unix < $min_date_unix || $entered_to_unix > $max_date_unix) {
    // times were set outside of the parent event's time, error
    form_set_error('field_event_date', t('Calls must be inside the event timerange of %from - %to.', array('%from' => date_format_date($min_date, 'custom', 'g:i a'), '%to' => date_format_date($max_date, 'custom', 'g:i a')))); 
  }
}

/**
 * Implements hook_node_validate().
 */
function schedulearts_node_validate($node, $form) {
}

/**
 * Implements hook_node_update()
 */
function schedulearts_node_update($node) {
  // If the date/time of an event has changed, update its Calls to the same relative times
  if ($node->type == 'event') {
    $old_node = reset(entity_load('node', array($node->nid)));
    if ($node->field_event_date['und']['0']['value'] != $old_node->field_event_date['und']['0']['value'] || $node->field_event_date['und']['0']['value2'] != $old_node->field_event_date['und']['0']['value2'])   {
    // Get UNIX timestamps for start, end for old and new nodes
    $old_event_start_unix = strtotime($old_node->field_event_date['und']['0']['value']);
    $old_event_end_unix = strtotime($old_node->field_event_date['und']['0']['value2']);
    $new_event_start_unix = strtotime($node->field_event_date['und']['0']['value']);
    $new_event_end_unix = strtotime($node->field_event_date['und']['0']['value2']);

      // Calculate difference between old and new dates
      $time_change = $new_event_start_unix - $old_event_start_unix;

      $calls = db_query("SELECT node.title AS node_title, node.nid AS nid, 'node' AS field_data_field_event_date_node_entity_type, 'node' AS field_data_body_node_entity_type, 'node' AS field_data_field_event_groups_tax_node_entity_type, 'node' AS field_data_field_event_individuals_node_entity_type
        FROM 
    {node} node
    LEFT JOIN {field_data_field_call_parent_event} field_data_field_call_parent_event ON node.nid = field_data_field_call_parent_event.entity_id AND (field_data_field_call_parent_event.entity_type = 'node' AND field_data_field_call_parent_event.deleted = '0')
    INNER JOIN {node} node_field_data_field_call_parent_event ON field_data_field_call_parent_event.field_call_parent_event_target_id = node_field_data_field_call_parent_event.nid
    WHERE (( (node.status = '1') AND (node_field_data_field_call_parent_event.nid = :nid) )AND(( (node.type IN  ('call')) )))", array(":nid" => $node->nid));
      foreach ($calls as $call) {
        $call_entity = reset(entity_load('node', array($call->nid)));
        // Add the time difference to start/end dates
        $new_start_unix = (strtotime($call_entity->field_event_date['und']['0']['value']) + $time_change);
        $call_entity->field_event_date['und']['0']['value'] = date('Y-m-d H:i:s', $new_start_unix);
        $new_end_unix = (strtotime($call_entity->field_event_date['und']['0']['value2']) + $time_change);
        $call_entity->field_event_date['und']['0']['value2'] = date('Y-m-d H:i:s', $new_end_unix);
        // Save and notify the user
        node_save($call_entity);
        drupal_set_message(t('Call %name has been moved to match the new event time', array('%name' => $call_entity->title)));
        // Sanity check - if the new call times are outside the new event times, warn the user
        if ($new_end_unix > $new_event_end_unix || $new_end_unix < $new_event_start_unix || $new_start_unix < $new_event_start_unix || $new_start_unix > $new_event_end_unix) {
          drupal_set_message(t('WARNING: The call times for %name are set outside the new Event times.', array('%name' => $call_entity->title)), 'warning');
        }
      }
    }
  }
}

/*
 * Add my custom stylesheet to all themes
 */
function schedulearts_init() {
  $options = array(
    'group' => CSS_THEME,
    'every_page' => TRUE,
    'weight' => 9999
  );
  drupal_add_css(drupal_get_path('module', 'schedulearts') . '/schedulearts.css', $options);
}

/*
 * Implements hook_menu
 * Improving the access callback requirements for taxonomy term add forms
 */
function schedulearts_menu() {
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/add'] = array(
    'access callback' => 'schedulearts_vocabulary_access',
    'access arguments' => array(3),
    'title' => 'Add term',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_form_term', array(), 3),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'taxonomy.admin.inc',
    'file path' => 'modules/taxonomy',
  );
  return $items;
}

// Custom access callback for taxonomy term add form - checks that you can EDIT the vocab
function schedulearts_vocabulary_access($vid) {
  return user_access("edit terms in $vid->vid") || user_access('administer taxonomy');
}
